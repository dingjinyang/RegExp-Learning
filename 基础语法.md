# 正则表达式基础语法

正则表达式（regulae expression)是一个描述字符串模式的对象。JavaScript 的 RegExp 类表示正则表达式类，String 和 RegExp 都定义了方法，后者使用正则表达式进行强大的模式匹配和文本检索与替换功能。JavaScript 的正则表达式是`Perl5`
的正则表达式语法的大型子集。

> Perl5 (Practical Extraction and Report Language)，它是由 Larry Wall 设计的，并由他不断更新和维护，用于在 UNIX 环境下编程的一种编程语言。[官方网站](http://www.perl.org) [中文教程](http://net.pku.edu.cn/~yhf/tutorial/perl/perl.html)

- [正则表达式的定义](#正则表达式的定义)
  - [直接量字符串](#直接量字符串)
  - [字符类](#字符类)
  - [重复](#重复)
    - [非贪婪的重复](#非贪婪的重复)
  - [选择、分组和引用](#选择分组和引用)
    - [分割线：|](#分割线)
    - [圆括号：(...)](#圆括号)
    - [字符：(?:...)](#字符)
  - [指定匹配位置](#指定匹配位置)
    - [先行断言](#先行断言)
    - [负向先行断言](#负向先行断言)
  - [修饰符](#修饰符)

## 正则表达式的定义

JavaScript 的正则表达式是用 RegExp 对象表示，可是用 RegExp()构造函数来创建对象，RegExp 对象更多是通过直接量语法创建，正则表达式直接量定义为包含在一对斜杠（ / ）之间的字符。

```javascript
var pattern = new RegExp("s$"); //匹配所有以字母“s”结尾的字符串
var pattern = /s$/; //与上等价
```

> 正则表达式直接量与对象、数组、字符串等不同：
> -- ECMAScript 3 规范规定，一个正则表达式直接量在执行到它时转换为一个 RegExp 对象，同一段代码所表示正则表达式直接量每次运行都返回同一个对象。
> -- ECMAScript 5 规范则做了相反的规定，同一段代码所表示正则表达式直接量每次运行都返回新对象。

正则表达式的模式规则是由一个字符序列组成的。包括所有字母和数字在内，大多数都是按照直接量仅描述待匹配的字符串，例如正则表达式`/javascript/`可以匹配任何包含`javascript`子串的字符串。除此之外还包含其他具有特殊语义的字符，他们并不按照字面含义匹配。比如`/s$/`，`$`是一个具有特殊语义的元字符，用以匹配字符串的结束，所以这个正则表达式可以匹配任何以"s"结尾的字符串。

### 直接量字符串

正则表达式中的所有字母和数字都是按照字面含义进行匹配的。通过反斜线（ \ ）作为前缀进行转义可支持非字母的字符匹配。下表为正则表达式中的直接量字符

| 字符             | 匹配                                                            |
| ---------------- | --------------------------------------------------------------- |
| Content cell 1   | Content cell 2                                                  |
| Content column 1 | Content column 2                                                |
| \o               | NUL 字符                                                        |
| \t               | 制表符                                                          |
| \n               | 换行符                                                          |
| \v               | 垂直制表符                                                      |
| \f               | 换页符                                                          |
| \r               | 回车符                                                          |
| \x*nn*           | 由十六进制数 nn 指定的拉丁字符，例如：`\OA` 等价于 `\n`         |
| \u*xxxx*         | 由十六进制数 xxxx 指定的 Unicode 字符，例如：`\u0009`等价于`\t` |
| \c*X*            | 控制字符^_X_，例如：`\cJ`等价于`\n`                             |

> 正则表达式中具有特殊含义的标点符号：`^` `$` `.` `*` `+` `?` `=` `!` `:` `|` `\` `/` `(` `)` `[` `]` `{` `}`，正则表达式中匹配这些符号需要转义

### 字符类

将直接量字符单独放进括号内就组成了字符类。一个字符类可以匹配它所包含的任意字符。例如：正则表达式`/[abc]/`可以和字母"a"、"b"、"c"中的的任何一个匹配，正则表达式`/[^abc]/`匹配"a"、"b"、"c"以外的所有字符。字符类可以使用连字符`-`来表示字符范围，如`[a-zA-z0-9]`

| 字符   | 匹配                                              |
| ------ | ------------------------------------------------- |
| [...]  | 方括号内的任意字符                                |
| [^...] | 不在方括号内的任意字符                            |
| .      | 除换行符和其他 Unicode 行终止符之外的任意字符     |
| \w     | 任何 ASCII 字符组成的单词，等价于[a-zA-z0-9]      |
| \W     | 任何不是 ASCII 字符组成的单词，等价于[^a-za-z0-9] |
| \s     | 任何 Unicode 空白符                               |
| \S     | 任何 非 Unicode 空白符，注意\w 和\S 不同          |
| \d     | 任何 ASCII 数字，等价于[0-9]                      |
| \D     | 除 ASCII 数字之外的任何字符，等价于[^0-9]         |
| [\b]   | 退格直接量（特例）                                |

> 方括号内也可以使用特殊转义字符，如`/[\s\d]/`匹配任意空白符或数字。特例：`[\b]`表示退格符

### 重复

在正则模式之后跟随用以指定的字符重复标记

| 字符  | 含义                                  |
| ----- | ------------------------------------- |
| {n,m} | 匹配前一项至少 n 次，但不能超过 m 此  |
| {n,}  | 匹配前一项 n 次或更多次               |
| {n}   | 匹配前一项 n 次                       |
| ?     | 匹配前一项 0 次或者 1 次，等价于{0,1} |
| +     | 匹配前一项 1 次或多次,等价于{1,}      |
| \*    | 匹配前一项 0 次或多次,等价于{0,n}     |

```javascript
let pattern1 = /\d{2,4}/; //匹配2-4个数字
let pattern2 = /\w{3}\d?/; //精确匹配三个单词和一个可选数字
let pattern3 = /\s+java\s+/; //匹配前后带有一个或多个空格的字符串"java"
let pattern4 = /[^(]*/; //匹配一个或多个非左括号的字符
```

#### 非贪婪的重复

上表中的重复匹配字符是尽可能多的匹配，而且允许后续的正则表达式继续匹配，称为“贪婪的”匹配。非贪婪匹配只需在待匹配的字符后跟随一个问号即可。例如：`/a+/`匹配一个或多个连续的字母 a，而`/a+?`尽可能少的匹配一个或多个 a

```javascript
/a+/.exec("aaa"); // => ["aaa", index: 0, input: "aaa", groups: undefined]
/a+?/.exec("aaa"); // => ["a", index: 0, input: "aaa", groups: undefined]
```

### 选择、分组和引用

正则表达式的语法还包括指定选择项、子表达式分组和引用前一子表达式的特殊字符。

#### 分割线：|

用于分隔供选择的字符，例如：`/\d{3}|[a-z]{4}`匹配三位数字或四个小写字母

> 选择项的匹配次序为从左到右，直到发现为止，即使接下来有更好的匹配项，例如`/a|ab/`匹配"ab"时只能匹配第一个字符

#### 圆括号：()

- 把单独的项合成子表达式，像独立的单元一样处理。例如`/java(script)?/`可以匹配字符串"java"，其后可以有"script"也可以没有
- 在完整的模式中定义子模式，当一个正则表达式成功匹配时，可以从目标串中抽出和圆括号中的子模式相匹配的部分
- 在同一正则表达式的后部引用前面的子表达式，通过在字符"\"后加一位或多位数字实现。例如，\1 是引用第一个带圆括号的子表达式。
  > 对子表达式的引用并不是对子表达式模式的引用，而是与那个模式相匹配的文本的引用。
  > 例如：`/(['"])[^'"]*\1/`匹配左右两侧的引号

#### 字符：(?:)

只进行分组而不创建带数字编码的引用，例如`/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/`,子表达式`(?:[Ss]cript)`仅仅用于分组，并不生成引用，因此\2 引用与`(fun\w*)`相匹配的文本。

| 字符    | 含义                                                                                                                                       |
| ------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| \|      | 选择，匹配的是该符号左边的子表达式或右边的子表达式                                                                                         |
| (...)   | 组合，将几个项目组合为一个单元，这个单元可以通过”\*“、”+“、”?“和”\|“等符号加以修饰，而且可以记住和这个组合相匹配的字符串以供此后的引用使用 |
| (?:...) | 只组合，把项组合到一个单元，但不记忆与该组相匹配的字符                                                                                     |
| \n      | 和第 n 个分组第一次匹配的字符向匹配，组是圆括号中的子表达式（也有可能时嵌套的），组索引是从左到右的左括号数，“(?:“形式的分组不编码         |

### 指定匹配位置

正则表达式中多个元素才能够匹配字符串的一个字符，其中还有一些正则表达式的元素匹配的是字符之间的位置。

| 字符      | 含义                                                                                                                                        |
| --------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| ^         | 匹配字符串的开头，在多行检索中，匹配一行的开头                                                                                              |
| \$        | 匹配字符串的结尾，在多行检索中，匹配一行的结尾                                                                                              |
| \b        | 匹配一个单词的边界，简言之，就是位于字符\w 和\W 之间的位置，或位于字符\w 和字符串的开头或者结尾之间的位置（但需要注意，[\b]匹配的是退格符） |
| \B        | 匹配非单词边界的位置                                                                                                                        |
| (\?\=_p_) | 零宽正向先行断言，要求接下来的字符都与 _p_ 匹配，但不能包括匹配*p*的那些字符                                                                |
| (?!p)     | 零宽负向先行断言，要求接下来的字符都不与 _p_ 匹配                                                                                           |

例如，要匹配单词“JavaScript”，可以使用正则表达式`/^JavaScript$/`；正则表达式`/\bJava\b`可匹配单词 Java，而正则表达式`/\B[Ss]cript/`与“JavaScript”和“postscript”匹配，但不与“script”和“Scripting”匹配

#### 先行断言

如果在符号“(?=”和“)”之间加入一个表达式，他就是一个先行断言，用以说明圆括号内的表达式必须正确匹配，但不是真正意义上的匹配。比如：`/[Jj]ava([Ss]cript)?(?=\:)/`可以匹配“JavaScript: The Definitive Guide”中的 “JavaScript”，但是不能匹配“Java in a Nutshell”中的 “Java”，因为它后面没有括号。

#### 负向先行断言

指定接下来的字符都不必匹配。例如：`/Java(?!Script)([A-Z]\w*)/`可以匹配“Java”后跟随一个大写字母和任意多个 ASCII 单词，但 Java 后面不能跟随“Script”。

### 修饰符

正则表达式的修饰符用以说明高级的匹配模式的规则。

| 字符 | 含义                                                                      |
| ---- | ------------------------------------------------------------------------- |
| i    | 执行不区分大小写的匹配                                                    |
| g    | 执行一个全局匹配，简言之，即找到所有的匹配，而不是找到第一个之后就停止    |
| m    | 多行匹配模式，^匹配一行的开头和字符串的开头，\$匹配行的结束和字符串的结束 |
